<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>avalonia on 寒流の编程笔记</title><link>https://blog.coldwind.top/tags/avalonia/</link><description>Recent content in avalonia on 寒流の编程笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 23 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.coldwind.top/tags/avalonia/index.xml" rel="self" type="application/rss+xml"/><item><title>分享一些针对 WPF 开发者的 Avalonia 开发技巧</title><link>https://blog.coldwind.top/posts/avalonia-tips-for-wpf-developers/</link><pubDate>Thu, 23 Oct 2025 00:00:00 +0000</pubDate><guid>https://blog.coldwind.top/posts/avalonia-tips-for-wpf-developers/</guid><description>&lt;p>Avalonia 在设计上借鉴了 WPF 的许多概念，开发体验来说也有很多相似之处。比如 XAML 语法、数据绑定、样式与模板等等，这使得 WPF 开发者能够较快上手 Avalonia。然而，Avalonia 也有其独特之处和最佳实践。如果对这些不够了解，WPF 开发者可能会将一些 WPF 的习惯直接套用到 Avalonia 上，导致代码不够高效或难以维护。&lt;/p>
&lt;p>本文将分享一些针对 WPF 开发者在使用 Avalonia 时的实用建议，帮助大家更好地适应和利用 Avalonia 的特性，从而提升开发效率和应用性能。&lt;/p>
&lt;h2 id="布局控件的改良">
布局控件的改良
&lt;a href="#%e5%b8%83%e5%b1%80%e6%8e%a7%e4%bb%b6%e7%9a%84%e6%94%b9%e8%89%af" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;h3 id="子控件间距">
子控件间距
&lt;a href="#%e5%ad%90%e6%8e%a7%e4%bb%b6%e9%97%b4%e8%b7%9d" class="anchor">&amp;para;&lt;/a>
&lt;/h3>&lt;p>Avalonia 为一些常用的布局控件提供了方便好用的属性。其中最方便的就是与 &lt;code>Spacing&lt;/code> 相关的一些属性。在 WPF 中，如果想让控件之间有间距，通常需要使用 &lt;code>Margin&lt;/code> 属性，导致代码看起来非常冗长：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;StackPanel&lt;/span> &lt;span class="na">Orientation=&lt;/span>&lt;span class="s">&amp;#34;Horizontal&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Button&lt;/span> &lt;span class="na">Content=&lt;/span>&lt;span class="s">&amp;#34;Button 1&amp;#34;&lt;/span> &lt;span class="na">Margin=&lt;/span>&lt;span class="s">&amp;#34;0,0,10,0&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Button&lt;/span> &lt;span class="na">Content=&lt;/span>&lt;span class="s">&amp;#34;Button 2&amp;#34;&lt;/span> &lt;span class="na">Margin=&lt;/span>&lt;span class="s">&amp;#34;0,0,10,0&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Button&lt;/span> &lt;span class="na">Content=&lt;/span>&lt;span class="s">&amp;#34;Button 3&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/StackPanel&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但是在 Avalonia 中，可以直接使用 &lt;code>Spacing&lt;/code> 属性来设置控件之间的间距，使代码更加简洁：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;StackPanel&lt;/span> &lt;span class="na">Orientation=&lt;/span>&lt;span class="s">&amp;#34;Horizontal&amp;#34;&lt;/span> &lt;span class="na">Spacing=&lt;/span>&lt;span class="s">&amp;#34;10&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Button&lt;/span> &lt;span class="na">Content=&lt;/span>&lt;span class="s">&amp;#34;Button 1&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Button&lt;/span> &lt;span class="na">Content=&lt;/span>&lt;span class="s">&amp;#34;Button 2&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Button&lt;/span> &lt;span class="na">Content=&lt;/span>&lt;span class="s">&amp;#34;Button 3&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/StackPanel&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>除了 &lt;code>StackPanel&lt;/code>，&lt;code>WrapPanel&lt;/code>、&lt;code>Grid&lt;/code> 和 &lt;code>UniformGrid&lt;/code> 也支持 &lt;code>Spacing&lt;/code> 属性。具体来说：&lt;/p>
&lt;ul>
&lt;li>&lt;code>StackPanel&lt;/code>：
&lt;ul>
&lt;li>&lt;code>Spacing&lt;/code>：设置子项之间的间距&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>WrapPanel&lt;/code>：
&lt;ul>
&lt;li>&lt;code>ItemSpacing&lt;/code>：设置子项之间的间距&lt;/li>
&lt;li>&lt;code>LineSpacing&lt;/code>：设置行之间的间距&lt;/li>
&lt;li>&lt;code>ItemsAlignment&lt;/code>：设置整行（或列，取决于方向）的对齐方式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Grid&lt;/code> 与 &lt;code>UniformGrid&lt;/code>：
&lt;ul>
&lt;li>&lt;code>RowSpacing&lt;/code>：设置行之间的间距&lt;/li>
&lt;li>&lt;code>ColumnSpacing&lt;/code>：设置列之间的间距&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>使用这些属性可以让布局代码更加简洁易读，避免了大量的 &lt;code>Margin&lt;/code> 设置。&lt;/p>
&lt;h3 id="grid-控件">
&lt;code>Grid&lt;/code> 控件
&lt;a href="#grid-%e6%8e%a7%e4%bb%b6" class="anchor">&amp;para;&lt;/a>
&lt;/h3>&lt;p>在 Avalonia 中，&lt;code>Grid&lt;/code> 也迎来了一些开发体验的优化。除了上面提到的 &lt;code>RowSpacing&lt;/code> 和 &lt;code>ColumnSpacing&lt;/code> 属性外，&lt;code>Grid&lt;/code> 还支持 &lt;code>RowDefinitions&lt;/code> 和 &lt;code>ColumnDefinitions&lt;/code> 的简化语法。我们现在可以用字符串的形式来快速定义行和列：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;Grid&lt;/span> &lt;span class="na">ColumnDefinitions=&lt;/span>&lt;span class="s">&amp;#34;Auto,*,100&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c">&amp;lt;!-- WPF 的做法 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Grid.RowDefinitions&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;RowDefinition&lt;/span> &lt;span class="na">Height=&lt;/span>&lt;span class="s">&amp;#34;Auto&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;RowDefinition&lt;/span> &lt;span class="na">Height=&lt;/span>&lt;span class="s">&amp;#34;*&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;RowDefinition&lt;/span> &lt;span class="na">Height=&lt;/span>&lt;span class="s">&amp;#34;100&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Grid.RowDefinitions&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/Grid&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="notice tip">
&lt;div class="notice-title">
&lt;i class="fa-solid fa-lightbulb" aria-hidden="true">&lt;/i>Tip
&lt;/div>
&lt;div class="notice-content">如果需要操作这些 &lt;code>Definition&lt;/code>，比如在运行时动态调整它们的可见性、尺寸等，那我们仍然需要使用传统的方式来定义。&lt;/div>
&lt;/div>
&lt;p>此外，如果我们的布局要求非常简单，比如并不会用到行与列，只是简单地将子控件堆叠在一起，最多是借助它们的 &lt;code>Alignment&lt;/code> 属性来调整位置，那么我们可以使用更加轻量的 &lt;code>Panel&lt;/code> 控件来替代 &lt;code>Grid&lt;/code>，以提升性能。而 WPF 因为缺乏这样的轻量级容器，往往会过度使用 &lt;code>Grid&lt;/code>，导致性能下降。也因此，不少第三方控件库提供了诸如 &lt;code>SimplePanel&lt;/code> 之类的轻量级容器来弥补这一缺陷。&lt;/p>
&lt;h2 id="集合类型">
集合类型
&lt;a href="#%e9%9b%86%e5%90%88%e7%b1%bb%e5%9e%8b" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>在 WPF 中，我们都知道，如果想要让前台的 &lt;code>ItemsControl&lt;/code>（及其子类，如 &lt;code>ListBox&lt;/code>、&lt;code>ComboBox&lt;/code> 等）能够响应集合的变化，我们需要使用 &lt;code>ObservableCollection&amp;lt;T&amp;gt;&lt;/code> 作为数据源，因为它实现了 &lt;code>INotifyCollectionChanged&lt;/code> 接口，能够在集合发生变化时通知 UI 更新。&lt;/p>
&lt;p>而在 Avalonia 中，我们可以考虑使用它提供的 &lt;code>AvaloniaList&amp;lt;T&amp;gt;&lt;/code> 作为集合类型。简单来说，&lt;code>AvaloniaList&amp;lt;T&amp;gt;&lt;/code> 提供了以下几条额外的功能：&lt;/p>
&lt;ol>
&lt;li>可以设置 &lt;code>ResetBehavior&lt;/code> 属性来控制集合被清空时触发的是 &lt;code>NotifyCollectionChangedAction.Reset&lt;/code> 还是 &lt;code>Remove&lt;/code>：&lt;code>Reset&lt;/code> 仅通知，但事件参数不包含具体删除了哪些元素，而 &lt;code>Remove&lt;/code> 则会包含被删除的元素列表&lt;/li>
&lt;li>提供了 &lt;code>Validate&lt;/code> 方法，可以在添加元素时进行验证&lt;/li>
&lt;li>提供了 &lt;code>AddRange&lt;/code> 和 &lt;code>RemoveRange&lt;/code> 方法，可以一次性添加或移除多个元素&lt;/li>
&lt;/ol>
&lt;p>这些新功能可以说是显著提升了 &lt;code>ObservableCollection&amp;lt;T&amp;gt;&lt;/code> 的使用体验。&lt;/p>
&lt;p>Avalonia 还提供了 &lt;code>AvaloniaDictionary&amp;lt;,&amp;gt;&lt;/code>，它是一个具备通知功能的字典类型。WPF 因为缺乏类似 &lt;code>ObservableDictionary&amp;lt;,&amp;gt;&lt;/code> 的类型，往往需要开发者自行实现，而 Avalonia 则直接提供了现成的解决方案供我们使用。&lt;/p>
&lt;p>此外，对于 &lt;code>DataGrid&lt;/code> 控件，Avalonia 还提供了 &lt;code>DataGridCollectionView&lt;/code>，它是一个支持排序、过滤、分组等功能的集合视图类型，可以大大提高数据展示的灵活性。在 11.3.x 版本的 Avalonia 中，它被迁移到了 &lt;code>Avalonia.Controls.DataGrid&lt;/code> 包中，方便我们单独引用。&lt;/p>
&lt;h2 id="值转换器">
值转换器
&lt;a href="#%e5%80%bc%e8%bd%ac%e6%8d%a2%e5%99%a8" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>在 WPF 中，我们常常需要与值转换器（&lt;code>IValueConverter&lt;/code>）打交道，以便在数据绑定时对数据进行转换。WPF 原生几乎只提供了一个我们用得上的转换器——&lt;code>BooleanToVisibilityConverter&lt;/code>。其他的转换器通常需要我们自己实现。这同时也因为 WPF 的绑定语法不够灵活，导致连一个简单的布尔值取反都需要我们自己写转换器。&lt;/p>
&lt;p>而在 Avalonia 中，情况则大不相同。甚至可以说，在遇到看似需要我们写值转换器的场景时，我们应该先考虑是否可以通过 Avalonia 提供的内置功能来实现，并且很多时候都是可以的。&lt;/p>
&lt;h3 id="内置转换器">
内置转换器
&lt;a href="#%e5%86%85%e7%bd%ae%e8%bd%ac%e6%8d%a2%e5%99%a8" class="anchor">&amp;para;&lt;/a>
&lt;/h3>&lt;p>Avalonia 提供了丰富的内置值转换器，涵盖了常见的转换需求。比如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>BoolConverters&lt;/code>
&lt;ul>
&lt;li>提供了一些多值转换器（&lt;code>IMultiValueConverter&lt;/code>），如 &lt;code>AndConverter&lt;/code>、&lt;code>OrConverter&lt;/code> 等，可用于 &lt;code>MultiBinding&lt;/code>&lt;/li>
&lt;li>提供了布尔值的取反转换器 &lt;code>NotConverter&lt;/code>，但通常可以用绑定表达式的特殊语法来实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>StringConverters&lt;/code>
&lt;ul>
&lt;li>提供了一些与字符串有关的转换器，如 &lt;code>IsNullOrEmpty&lt;/code>、&lt;code>IsNullOrWhiteSpace&lt;/code> 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ObjectConverters&lt;/code>
&lt;ul>
&lt;li>提供了一些与对象有关的转换器，如 &lt;code>IsNull&lt;/code>、&lt;code>IsNotNull&lt;/code>、&lt;code>Equal&lt;/code>、&lt;code>NotEqual&lt;/code> 等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>运用这些内置的转换器，我们可以轻易实现很多常见的需求，比如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="c">&amp;lt;!-- 只有当所有开关都打开时，提交按钮才可用 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;ToggleSwitch&lt;/span> &lt;span class="na">x:Name=&lt;/span>&lt;span class="s">&amp;#34;Toggle1&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;ToggleSwitch&lt;/span> &lt;span class="na">x:Name=&lt;/span>&lt;span class="s">&amp;#34;Toggle2&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;ToggleSwitch&lt;/span> &lt;span class="na">x:Name=&lt;/span>&lt;span class="s">&amp;#34;Toggle3&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;Button&lt;/span> &lt;span class="na">Content=&lt;/span>&lt;span class="s">&amp;#34;Submit&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Button.IsEnabled&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;MultiBinding&lt;/span> &lt;span class="na">Converter=&lt;/span>&lt;span class="s">&amp;#34;{x:Static BoolConverters.AndConverter}&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Binding&lt;/span> &lt;span class="na">ElementName=&lt;/span>&lt;span class="s">&amp;#34;Toggle1&amp;#34;&lt;/span> &lt;span class="na">Path=&lt;/span>&lt;span class="s">&amp;#34;IsChecked&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Binding&lt;/span> &lt;span class="na">ElementName=&lt;/span>&lt;span class="s">&amp;#34;Toggle2&amp;#34;&lt;/span> &lt;span class="na">Path=&lt;/span>&lt;span class="s">&amp;#34;IsChecked&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Binding&lt;/span> &lt;span class="na">ElementName=&lt;/span>&lt;span class="s">&amp;#34;Toggle3&amp;#34;&lt;/span> &lt;span class="na">Path=&lt;/span>&lt;span class="s">&amp;#34;IsChecked&amp;#34;&lt;/span>&lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/MultiBinding&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Button.IsEnabled&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/Button&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;ListBox&lt;/span> &lt;span class="na">x:Name=&lt;/span>&lt;span class="s">&amp;#34;MyListBox&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;TextBlock&lt;/span> &lt;span class="na">IsVisible=&lt;/span>&lt;span class="s">&amp;#34;{Binding #MyListBox.SelectedItem, Converter={x:Static ObjectConverters.IsNotNull}}&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> An item is selected
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/TextBlock&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="绑定表达式">
绑定表达式
&lt;a href="#%e7%bb%91%e5%ae%9a%e8%a1%a8%e8%be%be%e5%bc%8f" class="anchor">&amp;para;&lt;/a>
&lt;/h3>&lt;p>Avalonia 的绑定表达式语法也比 WPF 更加灵活强大。我们可以在绑定路径中直接使用一些特殊的语法来实现简单的转换需求，而无需借助值转换器。&lt;/p>
&lt;p>比如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="c">&amp;lt;!-- 布尔值取反 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;ToggleSwitch&lt;/span> &lt;span class="na">x:Name=&lt;/span>&lt;span class="s">&amp;#34;MyToggle&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;TextBlock&lt;/span> &lt;span class="na">IsVisible=&lt;/span>&lt;span class="s">&amp;#34;{Binding #MyToggle.IsChecked, Path=!}&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> The toggle is off
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/TextBlock&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&amp;lt;!-- 字符串不为空 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;TextBox&lt;/span> &lt;span class="na">x:Name=&lt;/span>&lt;span class="s">&amp;#34;MyTextBox&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;TextBlock&lt;/span> &lt;span class="na">IsVisible=&lt;/span>&lt;span class="s">&amp;#34;{Binding !!#MyTextBox.Text}&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Text is not empty
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/TextBlock&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过这些内置的转换器和灵活的绑定表达式语法，我们可以大大减少自定义值转换器的编写，从而简化代码，提高开发效率。&lt;/p>
&lt;h3 id="函数值转换器">
函数值转换器
&lt;a href="#%e5%87%bd%e6%95%b0%e5%80%bc%e8%bd%ac%e6%8d%a2%e5%99%a8" class="anchor">&amp;para;&lt;/a>
&lt;/h3>&lt;p>如果上面的这些方式还不能满足，那么或许依然不必急于去写值转换器。Avalonia 还提供了函数值转换器（&lt;code>FuncValueConverter&lt;/code>），它允许我们快速地在后台代码中定义一个转换函数，并将其直接用于绑定中，而无需创建一个完整的转换器类。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">MyViewModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">FuncValueConverter&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">bool&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">StringToBoolConverter&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">str&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">IsNullOrEmpty&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;TextBox&lt;/span> &lt;span class="na">x:Name=&lt;/span>&lt;span class="s">&amp;#34;MyTextBox&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;TextBlock&lt;/span> &lt;span class="na">IsVisible=&lt;/span>&lt;span class="s">&amp;#34;{Binding #MyTextBox.Text, Converter={x:Static local:MyViewModel.StringToBoolConverter}}&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Text is not empty
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/TextBlock&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过这种方式，我们可以快速地实现一些简单的转换逻辑，而无需编写冗长的转换器类，从而提高开发效率。如果希望传入参数（&lt;code>ConverterParameter&lt;/code>），它还有一个 &lt;code>FuncValueConverter&amp;lt;TIn, TParam, TOut&amp;gt;&lt;/code> 的重载版本，可以满足这一需求。此外，我们还有 &lt;code>FuncMultiValueConverter&lt;/code> 可供使用，适用于多值绑定的场景。&lt;/p>
&lt;p>但需要注意，这种方式存在一定局限性：它只支持正向转换（&lt;code>Convert&lt;/code> 方法），不支持反向转换（&lt;code>ConvertBack&lt;/code> 方法）。因此，如果需要更复杂的转换逻辑，仍然需要编写完整的值转换器类。&lt;/p>
&lt;h2 id="xmlns-命名空间">
xmlns 命名空间
&lt;a href="#xmlns-%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>在 WPF 中，如果我们想要引入一个程序集中的控件或类型，通常需要在 XAML 文件的开头使用 &lt;code>xmlns&lt;/code> 声明一个命名空间，并指定程序集名称：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;Window&lt;/span> &lt;span class="na">xmlns:md=&lt;/span>&lt;span class="s">&amp;#34;http://materialdesigninxaml.net/winfx/xaml/themes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">xmlns:local=&lt;/span>&lt;span class="s">&amp;#34;clr-namespace:MyApp.Controls&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">xmlns:classlib=&lt;/span>&lt;span class="s">&amp;#34;clr-namespace:ClassLibrary.Controls;assembly=ClassLibrary&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果在当前程序集，那么我们只需要 &lt;code>clr-namespace&lt;/code> 即可；如果是其他程序集，则需要加上 &lt;code>assembly&lt;/code> 部分。&lt;/p>
&lt;p>这样的方式在 Avalonia 中同样适用，但 Avalonia 还提供了更加简洁的 &lt;code>using&lt;/code> 语法，允许我们直接使用程序集名称来引入命名空间：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;Window&lt;/span> &lt;span class="na">xmlns:md=&lt;/span>&lt;span class="s">&amp;#34;http://materialdesigninxaml.net/winfx/xaml/themes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">xmlns:local=&lt;/span>&lt;span class="s">&amp;#34;using:MyApp.Controls&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="na">xmlns:classlib=&lt;/span>&lt;span class="s">&amp;#34;using:ClassLibrary.Controls&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>另外，Avalonia 的默认 &lt;code>x&lt;/code> 命名空间也为我们提供了不少便利。在 WPF 中，如果我们想在 XAML 中使用一些常见的类型，比如 &lt;code>String&lt;/code>、&lt;code>Int32&lt;/code>、&lt;code>Boolean&lt;/code> 等，通常需要显式地引入 &lt;code>System&lt;/code> 命名空间：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;Window&lt;/span> &lt;span class="na">xmlns:sys=&lt;/span>&lt;span class="s">&amp;#34;clr-namespace:System;assembly=mscorlib&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Window.Resources&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;sys:String&lt;/span> &lt;span class="na">x:Key=&lt;/span>&lt;span class="s">&amp;#34;MyString&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>Hello, World!&lt;span class="nt">&amp;lt;/sys:String&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;sys:Int32&lt;/span> &lt;span class="na">x:Key=&lt;/span>&lt;span class="s">&amp;#34;MyInt&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>42&lt;span class="nt">&amp;lt;/sys:Int32&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;sys:Boolean&lt;/span> &lt;span class="na">x:Key=&lt;/span>&lt;span class="s">&amp;#34;MyBool&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>True&lt;span class="nt">&amp;lt;/sys:Boolean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Window.Resources&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/Window&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="notice tip">
&lt;div class="notice-title">
&lt;i class="fa-solid fa-lightbulb" aria-hidden="true">&lt;/i>Tip
&lt;/div>
&lt;div class="notice-content">&lt;p>对于 .NET Framework 项目，我们必须引入 &lt;code>mscorlib&lt;/code> 程序集；而对于 .NET 5+ 项目，我们还将多一些选择，比如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>System.Core&lt;/code>&lt;/li>
&lt;li>&lt;code>System.Runtime&lt;/code>&lt;/li>
&lt;li>&lt;code>netstandard&lt;/code>&lt;/li>
&lt;/ul>&lt;/div>
&lt;/div>
&lt;p>而在 Avalonia 中，我们可以直接使用 &lt;code>x&lt;/code> 命名空间来引用这些常见类型，无需额外的 &lt;code>xmlns&lt;/code> 声明：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;Window&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;Window.Resources&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;x:String&lt;/span> &lt;span class="na">x:Key=&lt;/span>&lt;span class="s">&amp;#34;MyString&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>Hello, World!&lt;span class="nt">&amp;lt;/x:String&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;x:Int32&lt;/span> &lt;span class="na">x:Key=&lt;/span>&lt;span class="s">&amp;#34;MyInt&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>42&lt;span class="nt">&amp;lt;/x:Int32&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;x:Boolean&lt;/span> &lt;span class="na">x:Key=&lt;/span>&lt;span class="s">&amp;#34;MyBool&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>True&lt;span class="nt">&amp;lt;/x:Boolean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;lt;/Window.Resources&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;/Window&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="结语">
结语
&lt;a href="#%e7%bb%93%e8%af%ad" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>本文介绍了一些针对 WPF 开发者在使用 Avalonia 时的实用建议。通过了解和运用这些 Avalonia 的特性和最佳实践，WPF 开发者可以更好地适应 Avalonia 的开发环境，从而提升开发效率和应用性能。&lt;/p>
&lt;p>我们在使用 Avalonia 时，应该充分利用其提供的丰富功能和灵活语法，避免简单地将 WPF 的习惯直接套用到 Avalonia 上。希望本文的内容能够帮助大家更好地理解和使用 Avalonia，打造出高质量的跨平台应用程序。&lt;/p></description></item><item><title>借助 ObservableCollections 获得更多具有通知功能的集合类型</title><link>https://blog.coldwind.top/posts/more-observable-collections/</link><pubDate>Fri, 11 Jul 2025 00:00:00 +0000</pubDate><guid>https://blog.coldwind.top/posts/more-observable-collections/</guid><description>&lt;p>如果大家在做基于 C# 的 WPF、Avalonia、Win UI 等开发，尤其是遵循 MVVM 模式时，遇到过下面的这些烦恼：&lt;/p>
&lt;ol>
&lt;li>&lt;code>ObservableCollection&lt;/code> 没有批量操作的功能（例如 &lt;code>AddRange&lt;/code>）&lt;/li>
&lt;li>缺少 &lt;code>ObservableDictionary&lt;/code>、&lt;code>ObservableSet&lt;/code>、&lt;code>ObservableQueue&lt;/code> 等集合类型&lt;/li>
&lt;li>难以实现诸如过滤、映射等功能&lt;/li>
&lt;/ol>
&lt;p>那么，&lt;code>ObservableCollections&lt;/code> 这个 NuGet 包一定可以帮到你。没错，它就提供了一系列实用的具有通知功能的集合类型，使我们在 WPF、Avalonia、甚至 Unity 开发中都能够用得上。&lt;/p>
&lt;h2 id="安装">
安装
&lt;a href="#%e5%ae%89%e8%a3%85" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>它的源代码链接在 &lt;a class="link" href="https://github.com/Cysharp/ObservableCollections" target="_blank" rel="noopener"
>GitHub&lt;/a> 上。&lt;/p>
&lt;p>如果想要安装它，我们只需要在 NuGet 包管理器中搜索 &lt;code>ObservableCollections&lt;/code>，或者直接在项目中运行以下命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">dotnet add package ObservableCollections
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装之后即可使用。注意它还有一个结尾包含 &lt;code>R3&lt;/code> 的版本，是为它开发的 R3 库而准备的，通常我们不需要使用。这个 R3 库简单来说，就是一个更加高性能的 Rx.NET。&lt;/p>
&lt;div class="notice info">
&lt;div class="notice-title">
&lt;i class="fa-solid fa-exclamation-circle" aria-hidden="true">&lt;/i>Info
&lt;/div>
&lt;div class="notice-content">说起它的开发者 &lt;a class="link" href="https://github.com/Cysharp" target="_blank" rel="noopener"
>Cysharp&lt;/a>，那可真的可以说是如雷贯耳。比如他们开发的 &lt;code>Unitask&lt;/code>，就是一个非常流行的适用于 Unity 的异步编程库；而他们开发的 &lt;code>ZLinq&lt;/code>，最近也是非常有名。油管上的 Nick Chapsas 也 &lt;a class="link" href="https://www.youtube.com/watch?v=pUBc9uutSZM" target="_blank" rel="noopener"
>曾经介绍过这个库&lt;/a>。&lt;/div>
&lt;/div>
&lt;h2 id="支持批量操作的可观测集合">
支持批量操作的可观测集合
&lt;a href="#%e6%94%af%e6%8c%81%e6%89%b9%e9%87%8f%e6%93%8d%e4%bd%9c%e7%9a%84%e5%8f%af%e8%a7%82%e6%b5%8b%e9%9b%86%e5%90%88" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>我们先来看一看它最简单的 &lt;code>ObservableList&lt;/code>。它是一个具有通知功能的列表，并且支持批量操作。我们只需要实例化，然后就可以使用它了：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MainViewModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">ObservableList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">_items&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">MainViewModel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 添加单个元素&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_items&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Item 1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 批量添加元素&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_items&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">AddRange&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">GetItems&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="n">IEnumerable&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">GetItems&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 假定这个方法可以从某个数据源获取一些数据&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过观察可以发现，这个集合类型提供了 &lt;code>CollectionChanged&lt;/code> 事件，我们可以通过订阅它来监听集合的变化。但是先不要想当然地认为它和 &lt;code>ObservableCollection&lt;/code> 一样。实际上，它的 &lt;code>CollectionChanged&lt;/code> 事件并不是来自我们熟悉的那个 &lt;code>INotifyCollectionChanged&lt;/code> 接口，而是这个库自带的一个接口。所以我们在上面的代码中，并没有直接将这个集合声明为 &lt;code>public&lt;/code> 的属性，从而在 XAML 中绑定。&lt;/p>
&lt;p>那么它为什么要这样做，让我们不能方便地使用呢？其实原因很简单：这个库不单单适用于 WPF，它还可以用于 Avalonia、Unity 等框架。为了兼容更多的框架，它就没有使用 &lt;code>INotifyCollectionChanged&lt;/code> 接口，而是提供了一个更通用的接口。&lt;/p>
&lt;p>但不必担心，它并没有止步于此，而是专门提供了方便我们在 WPF、Avalonia 等框架中使用的额外类型。简单来说，我们只需要调用它的下面这个方法，即可将它转为可以用于 XAML 绑定的集合对象：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MainViewModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">ObservableList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">_items&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">INotifyCollectionChangedSynchronizedViewList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">Items&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">MainViewModel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Items&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_items&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToNotifyCollectionChanged&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的 &lt;code>INotifyCollectionChangedSynchronizedViewList&lt;/code> 就继承了 &lt;code>INotifyCollectionChanged&lt;/code> 接口，因此实现了该接口的对象就可以直接在 XAML 中绑定使用，例如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="line">&lt;span class="cl">&lt;span class="nt">&amp;lt;ListBox&lt;/span> &lt;span class="na">ItemsSource=&lt;/span>&lt;span class="s">&amp;#34;{Binding Items}&amp;#34;&lt;/span> &lt;span class="nt">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来，我们只需要在后台操作 &lt;code>_items&lt;/code> 集合，它的变化即可同步到 &lt;code>Items&lt;/code> 集合中，从而在 UI 上自动更新。&lt;/p>
&lt;h2 id="创建集合视图">
创建集合视图
&lt;a href="#%e5%88%9b%e5%bb%ba%e9%9b%86%e5%90%88%e8%a7%86%e5%9b%be" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>实际上，对于 &lt;code>ObservableList&lt;/code>，我们除了可以使用 &lt;code>ToNotifyCollectionChanged&lt;/code> 方法将其转换为可以用于 XAML 绑定的集合类型外，还可以使用 &lt;code>ToNotifyCollectionChangedSlim&lt;/code> 方法，将它转为一个更加轻量级的集合类型。这个类型同样实现了 &lt;code>INotifyCollectionChanged&lt;/code> 接口，但它的性能更高，适用于需要频繁更新的场景。代价是，它将不提供 &lt;code>AddRange&lt;/code> 等批量操作方法。&lt;/p>
&lt;p>这时候可能有同学就会问了：我用 &lt;code>ObservableList&lt;/code> 而不是原生的 &lt;code>ObservableCollection&lt;/code>，不就是为了它提供的批量操作方法吗？如果我不需要批量操作，直接用 &lt;code>ObservableCollection&lt;/code> 不就行了吗？&lt;/p>
&lt;p>这就引出了我们即将介绍的下一个功能，同时也是这个库相当重要的功能：&lt;code>View&lt;/code>。这个 &lt;code>View&lt;/code> 不是我们常说的 MVVM 中的视图，而是指对集合的视图。它可以让我们在不改变原始集合的情况下，对集合进行过滤、映射等操作。我们不需要关注视图的实现细节，只需要操作后台的集合，即可将更改同步到界面中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MainViewModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">ObservableList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">_items&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">ISynchronizedView&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">_syncView&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">INotifyCollectionChangedSynchronizedViewList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">Items&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">MainViewModel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_syncView&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_items&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">CreateView&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToUpper&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Items&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_syncView&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToNotifyCollectionChanged&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">ToggleFilter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">bool&lt;/span> &lt;span class="n">useFilter&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">useFilter&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_syncView&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">AttachFilter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">StartsWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;A&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">// 过滤以 &amp;#34;A&amp;#34; 开头的元素&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_syncView&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ResetFilter&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 清除过滤器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="notice tip">
&lt;div class="notice-title">
&lt;i class="fa-solid fa-lightbulb" aria-hidden="true">&lt;/i>Tip
&lt;/div>
&lt;div class="notice-content">如果我们只是想使用映射功能，那么使用 &lt;code>ToNotifyCollectionChanged&lt;/code> 方法即可。它有一个重载，可以传入一个表示映射方式的 &lt;code>Func&lt;/code>。另外，它还支持传入一个类似 &lt;code>Dispatcher&lt;/code> 的参数，用于在 UI 线程上执行映射操作。至于为什么不是 WPF 中的 &lt;code>Dispatcher&lt;/code>，而是一个它自己声明的类型，这也是为了兼容更多的框架。&lt;/div>
&lt;/div>
&lt;p>在上面的代码中，我们创建了一个视图 &lt;code>_syncView&lt;/code>。在创建时，我们就指定了一个映射函数，将集合中的每个元素转换为大写形式。然后在 &lt;code>ToggleFilter&lt;/code> 方法中，我们可以通过 &lt;code>AttachFilter&lt;/code> 及 &lt;code>ResetFilter&lt;/code> 方法来添加或移除过滤器。就这样，我们轻松地实现了对集合的过滤和映射功能。&lt;/p>
&lt;p>简单想象一下，这些功能在 WPF、Avalonia 等框架中原本实现起来会多么麻烦。对于映射，我们可以借助 &lt;code>DataTemplate&lt;/code> 以及 &lt;code>ValueConverter&lt;/code> 来实现；而对于过滤，我们可能需要使用 &lt;code>CollectionView&lt;/code> 或者 &lt;code>ICollectionView&lt;/code> 等。这些都需要我们编写大量的样板代码。&lt;/p>
&lt;h2 id="可观测的字典">
可观测的字典
&lt;a href="#%e5%8f%af%e8%a7%82%e6%b5%8b%e7%9a%84%e5%ad%97%e5%85%b8" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>WPF 中其实有一个 &lt;a class="link" href="https://source.dot.net/#PresentationFramework/MS/Internal/Annotations/ObservableDictionary.cs" target="_blank" rel="noopener"
>&lt;code>ObservableDictionary&lt;/code>&lt;/a>，但它并不是 &lt;code>public&lt;/code> 的，只是标准库内部使用。或许我们可以使用一个 &lt;code>ObservableCollection&amp;lt;KeyValuePair&amp;lt;TKey, TValue&amp;gt;&amp;gt;&lt;/code> 来模拟一个字典，但这效率并不高，因为字典的添加、删除、查找等操作都是 $O(1)$ 的，而 &lt;code>ObservableCollection&lt;/code> 的这些操作都是 $O(n)$ 的。&lt;/p>
&lt;p>至于 Avalonia，我们就比较幸运了，它直接提供了 &lt;code>AvaloniaList&lt;/code> 和 &lt;code>AvaloniaDictionary&lt;/code>，这两个集合类型，前者支持批量操作，后者则是一个可观测的字典。&lt;/p>
&lt;p>下面我们用一个简单的例子来演示如何使用这个 &lt;code>ObservableDictionary&lt;/code>。它的使用方式和 &lt;code>ObservableList&lt;/code> 类似，我们只需要实例化它，然后就可以使用了：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MainViewModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">ObservableDictionary&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">_items&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">INotifyCollectionChangedSynchronizedViewList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">Items&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">MainViewModel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Items&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_items&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToNotifyCollectionChanged&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pair&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Value&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_items&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Key1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Value1&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="可观测的队列">
可观测的队列
&lt;a href="#%e5%8f%af%e8%a7%82%e6%b5%8b%e7%9a%84%e9%98%9f%e5%88%97" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>队列有时候也是一个我们用得上的集合类型。它的特点是先进先出（FIFO），适用于需要按照顺序处理元素的场景。比如我们希望存储一些实时的消息，并且希望仅展示最新的几十条，而当超过这个数量时，自动删除最旧的消息。这就要求我们需要能够高效地删除队列头部的元素。这对于传统的列表来说是比较麻烦的，因为这会引入 $O(n)$ 的时间复杂度。&lt;/p>
&lt;p>&lt;code>ObservableCollections&lt;/code> 库提供了一个 &lt;code>ObservableQueue&amp;lt;T&amp;gt;&lt;/code>，不过我不打算详细介绍它，因为我们上面提到的需求有一个更加合适的集合类型，等下就会介绍到。但这里我们还是用一个简单的例子来演示它的用法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MainViewModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">ObservableQueue&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">LogMessage&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">_logQueue&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">INotifyCollectionChangedSynchronizedViewList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">LogMessage&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">LogMessages&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">MainViewModel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">LogMessages&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_logQueue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToNotifyCollectionChanged&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 添加日志消息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AddLogMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Application started&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">AddLogMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span> &lt;span class="n">content&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">logMessage&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LogMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">DateTime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Now&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;o&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">content&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 如果队列超过 100 条，则删除最旧的消息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">_logQueue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Count&lt;/span> &lt;span class="p">&amp;gt;=&lt;/span> &lt;span class="m">100&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_logQueue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Dequeue&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_logQueue&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Enqueue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">logMessage&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">record&lt;/span> &lt;span class="nc">LogMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span> &lt;span class="n">Timestamp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="n">Content&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="notice tip">
&lt;div class="notice-title">
&lt;i class="fa-solid fa-lightbulb" aria-hidden="true">&lt;/i>Tip
&lt;/div>
&lt;div class="notice-content">事实上，如果我们的需求只是比如说保留最近的几十到一百条消息，那么直接使用传统的 &lt;code>ObservableCollection&lt;/code> 也是完全可以接受的。虽然有点性能损失，但对于现在的 CPU 来说，这点复杂度完全是微不足道的。通过简单的 Benchmark，我们可以看到，&lt;code>List&lt;/code> 可能只比 &lt;code>Queue&lt;/code> 慢 50% 左右；甚至当数据量比较小（例如十几条）时，&lt;code>List&lt;/code> 更是能在性能上超过 &lt;code>Queue&lt;/code>。另外，&lt;code>List&lt;/code> 的使用显然比 &lt;code>Queue&lt;/code> 简单了不少。&lt;/div>
&lt;/div>
&lt;h2 id="可观测的环形缓冲区">
可观测的环形缓冲区
&lt;a href="#%e5%8f%af%e8%a7%82%e6%b5%8b%e7%9a%84%e7%8e%af%e5%bd%a2%e7%bc%93%e5%86%b2%e5%8c%ba" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>下面我们要介绍的这个集合类型，正是这个包最推荐我们用来实现这个保留最近的一些消息的集合类型：&lt;code>RingBuffer&lt;/code>。它是一个环形缓冲区，具有固定的大小。当添加新元素时，如果缓冲区已满，则会覆盖最旧的元素。这使得它非常适合用于存储最近的消息或数据。&lt;/p>
&lt;p>这个包提供了两种环形缓冲区：&lt;code>ObservableRingBuffer&lt;/code> 和 &lt;code>ObservableFixedSizeRingBuffer&lt;/code>。前者支持动态调整大小，而后者则是一个固定大小的环形缓冲区。借助后者，我们前面的例子可以简化为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MainViewModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">ObservableFixedSizeRingBuffer&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">LogMessage&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">_logBuffer&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">100&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">INotifyCollectionChangedSynchronizedViewList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">LogMessage&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">LogMessages&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">MainViewModel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">LogMessages&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_logBuffer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToNotifyCollectionChanged&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 添加日志消息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AddLogMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Application started&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">AddLogMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span> &lt;span class="n">content&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">logMessage&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LogMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">DateTime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Now&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;o&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">content&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_logBuffer&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">logMessage&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 添加新消息，自动覆盖最旧的消息&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就这样，我们轻松地实现了一个保留最近 100 条日志消息的集合。&lt;/p>
&lt;h2 id="线程安全">
线程安全
&lt;a href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>接下来这个部分相当重要，也是大家在使用这个包时需要尤其注意的，就是关于线程安全的问题。首先，这个包提供的每个集合都是线程安全的。它们内部会用一个线程锁，保证它的添加、删除等操作是线程安全的。但这并不意味着我们就可以高枕无忧了，因为虽然这些集合线程安全，但是从它们创建出的视图在同步它们的修改时，可能出现线程安全问题。那么，我们该怎么办呢？&lt;/p>
&lt;p>首先，在使用 &lt;code>ToNotifyCollectionChanged&lt;/code> 方法时，我们可以传入一个 &lt;code>Dispatcher&lt;/code> 参数。前面提到，这个参数是该类库自己声明的类型。但是它提供了一个方便我们使用的单例：&lt;code>SynchronizationContextCollectionEventDispatcher.Current&lt;/code>。借助它，我们就可以确保该方法创建出的视图在 UI 线程上执行修改操作，从而避免线程安全问题。&lt;/p>
&lt;p>但是这还不够。实测发现，虽然背后的集合本身线程安全，但是它创建出来的视图在操作时仍面临着线程安全问题。尤其是数据不一致。比如我们在删除元素之后立刻添加了元素，那么这两次动作在同步到视图的过程中就可能会出现问题。对于这个问题，如果我们确实有在多线程上操作背后集合的需求，那么我们可以考虑让这些操作都发生在主线程上。以 WPF 为例，我们可以这样：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-csharp" data-lang="csharp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MainViewModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="k">readonly&lt;/span> &lt;span class="n">ObservableList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">_items&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">INotifyCollectionChangedSynchronizedViewList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">Items&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">get&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">MainViewModel&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Items&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">_items&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ToNotifyCollectionChanged&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SynchronizationContextCollectionEventDispatcher&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Current&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">AddItem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 确保在 UI 线程上执行添加操作&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Application&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Current&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Dispatcher&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">InvokeAsync&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">_items&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">RemoveItem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 确保在 UI 线程上执行删除操作&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Application&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Current&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Dispatcher&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">InvokeAsync&lt;/span>&lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">_items&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Remove&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当然，在 &lt;code>ViewModel&lt;/code> 中访问 &lt;code>Application.Current&lt;/code> 可能并不是一个十分遵守 MVVM 模式的好习惯。因此在更加严谨的项目中，我们可以考虑将 &lt;code>Dispatcher&lt;/code> 作为参数传入 &lt;code>ViewModel&lt;/code>，或者使用依赖注入的方式来获取它。这样可以更好地遵循 MVVM 模式，同时也能确保在 UI 线程上执行操作。&lt;/p>
&lt;h2 id="总结">
总结
&lt;a href="#%e6%80%bb%e7%bb%93" class="anchor">&amp;para;&lt;/a>
&lt;/h2>&lt;p>&lt;code>ObservableCollections&lt;/code> 是一个非常实用的 NuGet 包，它提供了多种具有通知功能的集合类型，适用于 WPF、Avalonia、Win UI 等框架。它不仅支持批量操作，还提供了过滤、映射等功能，使得我们在开发中可以更加高效地处理集合数据。&lt;/p>
&lt;p>在使用时，我们需要注意线程安全问题，尤其是在多线程环境下操作集合时。通过合理地使用 &lt;code>Dispatcher&lt;/code>，我们可以确保集合的操作在 UI 线程上执行，从而避免数据不一致的问题。&lt;/p></description></item></channel></rss>