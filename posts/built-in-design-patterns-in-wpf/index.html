<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="本文探讨了在 WPF 框架中实现的多个经典设计模式，如观察者模式、桥接模式、装饰器模式等式。通过 WPF 的事件机制、依赖属性和附加属性等特性，展示了如何利用设计模式来增强代码的灵活性与扩展性。"><title>原生 WPF 框架中体现出的设计模式</title>
<link rel=canonical href=https://blog.coldwind.top/posts/built-in-design-patterns-in-wpf/><link rel=stylesheet href=/scss/style.min.1c23b918464bb2496e1a2213c41eb0c981727449579f04f0b661ec26d1435c17.css><meta property='og:title' content="原生 WPF 框架中体现出的设计模式"><meta property='og:description' content="本文探讨了在 WPF 框架中实现的多个经典设计模式，如观察者模式、桥接模式、装饰器模式等式。通过 WPF 的事件机制、依赖属性和附加属性等特性，展示了如何利用设计模式来增强代码的灵活性与扩展性。"><meta property='og:url' content='https://blog.coldwind.top/posts/built-in-design-patterns-in-wpf/'><meta property='og:site_name' content='寒流の编程笔记'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='dotnet'><meta property='article:tag' content='csharp'><meta property='article:tag' content='wpf'><meta property='article:tag' content='design-patterns'><meta property='article:published_time' content='2025-08-11T00:00:00+00:00'><meta property='article:modified_time' content='2025-08-11T00:00:00+00:00'><meta name=twitter:title content="原生 WPF 框架中体现出的设计模式"><meta name=twitter:description content="本文探讨了在 WPF 框架中实现的多个经典设计模式，如观察者模式、桥接模式、装饰器模式等式。通过 WPF 的事件机制、依赖属性和附加属性等特性，展示了如何利用设计模式来增强代码的灵活性与扩展性。"><link rel="shortcut icon" href=/favicon.png><link href=/css/fontawesome.min.css rel=stylesheet><link href=/css/brands.min.css rel=stylesheet><link href=/css/solid.min.css rel=stylesheet><link href=/css/regular.min.css rel=stylesheet></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu16872897465854023674.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>☘️</span></figure><div class=site-meta><h1 class=site-name><a href=/>寒流の编程笔记</a></h1><h2 class=site-description>记录那些稍纵即逝的编程心得。</h2></div></header><ol class=menu-social><li><a href=https://github.com/BYJRK target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://space.bilibili.com/600592 target=_blank title=Bilibili rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-bilibili"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 014-4h10a4 4 0 014 4v6a4 4 0 01-4 4H7a4 4 0 01-4-4v-6z"/><path d="M8 3l2 3"/><path d="M16 3l-2 3"/><path d="M9 13v-2"/><path d="M15 11v2"/></svg></a></li><li><a href=/index.xml target=_blank title=RSS rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-rss"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 19m-1 0a1 1 0 102 0 1 1 0 10-2 0"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>关于我</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><h2 class="widget-title section-title" style=font-size:2rem>目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#观察者模式>观察者模式</a></li><li><a href=#桥接模式>桥接模式</a></li><li><a href=#装饰器模式>装饰器模式</a></li><li><a href=#适配器模式>适配器模式</a></li><li><a href=#责任链模式>责任链模式</a></li><li><a href=#其他设计模式>其他设计模式</a></li><li><a href=#总结>总结</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/built-in-design-patterns-in-wpf/>原生 WPF 框架中体现出的设计模式</a></h2><h3 class=article-subtitle>本文探讨了在 WPF 框架中实现的多个经典设计模式，如观察者模式、桥接模式、装饰器模式等式。通过 WPF 的事件机制、依赖属性和附加属性等特性，展示了如何利用设计模式来增强代码的灵活性与扩展性。</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 11, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 6 分钟</time></div></footer></div></header><section class=article-content><p>我们在做软件开发时，经常会使用设计模式，比如单例模式、工厂模式、观察者模式等。这些设计模式帮助我们更好地组织代码，提高代码的可维护性和可扩展性。</p><p>但是这次我们换一个角度，来看一看框架本身有没有体现出这些设计模式。希望这篇文章可以给大家一个不一样的视角。</p><h2 id=观察者模式>观察者模式
<a href=#%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f class=anchor>&para;</a></h2><p>对于观察者模式，相信大多数人可能首先会想到的是在 MVVM 模式下，ViewModel 作为数据的提供者，而 View 作为数据的消费者。当 ViewModel 中的数据发生变化时，它会通知所有绑定的 View 进行更新（具体做法为实现 <code>INotifyPropertyChanged</code> 接口，并触发相应的事件）。这种模式使得 View 和 ViewModel 之间的交互变得简单而高效。</p><p>但实际上，原生 WPF 就已经充分体现出了观察者模式。对于大多数控件，本身它就提供了两种实现了观察者模式，或者说可以被观察的特性：</p><ol><li>事件：控件的事件机制允许开发者注册事件处理程序，从而在特定事件发生时接收通知。例如，当用户点击按钮时，按钮会触发 Click 事件；当用户修改文本框的内容时，文本框会触发 TextChanged 事件。</li><li>依赖属性：控件的依赖属性发生变化时，如果有绑定的目标，它会自动通知这些目标进行更新。这种机制使得控件的状态变化能够被及时“观察”到，从而实现了观察者模式的效果。</li></ol><p>所以，在 WPF 开发中，观察者模式并不仅仅体现在 MVVM 模式上，它在控件的事件和依赖属性中也得到了充分的体现。</p><h2 id=桥接模式>桥接模式
<a href=#%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8f class=anchor>&para;</a></h2><p>我们简单回顾一下桥接模式大概是怎么一回事：</p><p>如果我们的某一个类存在多个维度的变化（比如不同的外观和不同的行为），比如图形类可能有不同的形状（Shape）以及颜色（Color），那么假如我们采用传统的 OOP 的思想，就不可避免地会引入大量的子类，比如 <code>RedRectangle</code>、<code>BlueCircle</code> 等，这显然是不理想的。</p><p>此时，我们就可以使用桥接模式将这两个维度分离开来。这样一来，我们就可以独立地对这两个维度进行扩展，而不必相互影响。</p><p>这时候我们回来看 WPF，比如 <code>Control</code> 类就包含了多种不同的实现，包括 <code>Button</code>、<code>Label</code>、<code>TextBox</code> 等；同时，它们又都包含 <code>Background</code>、<code>Foreground</code> 等属性，用于控制它们实际的外观。这是否就和我们上面的例子不谋而合了？</p><p>所以，WPF 的 <code>Control</code> 类就是一个典型的桥接模式的实现。它将控件的外观（如样式、模板）和行为（如事件、命令）分离开来，使得我们可以独立地对这两个维度进行扩展。当然，体现桥接模式的不仅仅是 <code>Control</code> 类，其他很多控件也都遵循了这一模式。</p><h2 id=装饰器模式>装饰器模式
<a href=#%e8%a3%85%e9%a5%b0%e5%99%a8%e6%a8%a1%e5%bc%8f class=anchor>&para;</a></h2><p>装饰器模式（Decorator Pattern）是一种结构性设计模式，它允许在不改变对象自身的情况下，动态地给对象添加一些额外的职责。装饰器模式通常用于遵循开闭原则（对扩展开放，对修改关闭）。</p><p>在 WPF 中，装饰器模式的一个典型应用就是附加属性和行为了。通过附加属性，我们可以在不修改原有控件的情况下，为其添加新的功能。例如，我们可以为一个 <code>TextBox</code> 控件添加一个附加属性，用于控制其是否显示占位符文本。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;TextBox</span> <span class=na>local:TextBoxHelper.Placeholder=</span><span class=s>&#34;请输入内容&#34;</span> <span class=nt>/&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>在这个例子中，<code>TextBoxHelper</code> 就是一个提供了附加属性的类，它可以为任意 <code>TextBox</code> 控件添加占位符文本（<code>Placeholder</code>）属性。然后我们就可以在 <code>TextBox</code> 的 <code>Style</code> 或 <code>Template</code> 中响应这个附加属性，从而真的为文本框添加占位符。</p><p>行为也类似，而且行为本质上也是附加属性，或者说就是依靠附加属性来实现的。所以这里不再赘述。</p><p>所以我们可以说，附加属性利用了装饰器模式。不仅如此，其实它还体现出了其他一些设计模式，比如我们开头提到的观察者模式，此外还有享元模式（附加属性与依赖属性为同一类型的控件提供了相同的属性元数据）、中介者模式（比如一些与布局相关的附加属性，如 <code>DockPanel.Dock</code>、<code>Grid.Row</code> 等）等等。</p><h2 id=适配器模式>适配器模式
<a href=#%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f class=anchor>&para;</a></h2><p>在 WPF 的绑定中，我们常常会利用到值转换器（<code>ValueConverter</code>），它就是适配器模式的典型体现。</p><p>这里我们看一个最典型的例子：我们要将一个布尔属性绑定到控件的 <code>Visibility</code> 属性上。为了能够实现源类型（<code>bool</code>）到目标类型（<code>Visibility</code>）的转换，最常见的方式就是借助 <code>BooleanToVisibilityConverter</code> 了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;Window.Resources&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;BooleanToVisibilityConverter</span> <span class=na>x:Key=</span><span class=s>&#34;BooleanToVisibilityConverter&#34;</span> <span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/Window.Resources&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nt>&lt;Grid&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;TextBlock</span> <span class=na>Text=</span><span class=s>&#34;Hello, World!&#34;</span> <span class=na>Visibility=</span><span class=s>&#34;{Binding IsTextVisible, Converter={StaticResource BooleanToVisibilityConverter}}&#34;</span> <span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/Grid&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>另外，值转换器不仅体现出了适配器模式，还体现出了一定程度的策略模式。它们把“如何将一个值转换成另一个值”的算法抽象成一个接口（<code>IValueConverter</code>），并通过不同的实现类来提供具体的转换逻辑，这正是策略模式的核心思想——把一系列可互换的算法封装为独立的策略对象，并在运行时根据需要选择使用哪一个策略。</p><h2 id=责任链模式>责任链模式
<a href=#%e8%b4%a3%e4%bb%bb%e9%93%be%e6%a8%a1%e5%bc%8f class=anchor>&para;</a></h2><p>前面我们提到，控件的事件体现出了观察者模式。其实不仅如此，WPF 在传统 C# 事件的基础上，还引入了路由事件（<code>RoutedEvent</code>）这一概念。</p><p>路由事件允许事件在控件的视觉树中沿着特定的路径进行传播，这种传播机制使得我们可以在父级控件中处理子级控件的事件，或者反过来。具体要看路由的方式是冒泡（Bubble）还是隧道（Tunnel）。</p><p>但不管哪一种方式，我们都可以在事件的处理过程中形成一个责任链。对于这一点，最明显的体现方式就是对于 <code>e.Handled</code> 的使用。比如我们触发了一个鼠标事件，并且希望在某个父级控件中处理这个事件，那么我们可以在到达该控件时将 <code>e.Handled</code> 设置为 <code>true</code>，从而阻止事件继续向上传播。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>OnMouseDown</span><span class=p>(</span><span class=kt>object</span> <span class=n>sender</span><span class=p>,</span> <span class=n>MouseButtonEventArgs</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sender</span> <span class=k>is</span> <span class=n>Border</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 处理边框的鼠标按下事件</span>
</span></span><span class=line><span class=cl>        <span class=n>e</span><span class=p>.</span><span class=n>Handled</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span> <span class=c1>// 阻止事件继续向上传播</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这一操作就和责任链模式不谋而合：我们可以将事件的处理过程看作是一个链条，每个处理节点都可以选择是否将事件继续传递下去，从而形成一个灵活的事件处理机制。</p><h2 id=其他设计模式>其他设计模式
<a href=#%e5%85%b6%e4%bb%96%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f class=anchor>&para;</a></h2><p>除了上面这些典型的例子外，WPF 还体现出了很多其他的设计模式，比如：</p><ul><li><strong>状态模式</strong>：控件的视觉状态（如鼠标悬停、按下等）可以通过 VisualStateManager 进行管理，这实际上就是一种状态模式的应用。</li><li><strong>组合模式</strong>：WPF 的控件树结构使得我们可以将多个控件组合成一个复合控件，这正是组合模式的体现。</li><li><strong>单例模式</strong>：<code>Application.Current</code> 就是一个单例模式的实现。</li><li><strong>原型模式</strong>：WPF 中资源的 <code>Freezable</code> 以及 <code>Style</code> 被多个控件使用，都体现出了对于原型实例的“克隆”。</li></ul><h2 id=总结>总结
<a href=#%e6%80%bb%e7%bb%93 class=anchor>&para;</a></h2><p>在软件开发中，设计模式为我们提供了高效、灵活的解决方案，帮助提升代码的可维护性和可扩展性。本文通过分析 WPF 中的几个经典设计模式，如观察者模式、桥接模式、装饰器模式、适配器模式和责任链模式，展示了这些模式如何在 WPF 框架中得以体现。</p><p>通过控件的事件机制、依赖属性、附加属性等机制，WPF 为开发者提供了丰富的设计模式支持，帮助开发者更好地组织和扩展应用程序。除此之外，WPF 还体现了状态模式、组合模式、单例模式等其他设计模式，为开发者提供了多种优秀的架构思想。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/dotnet/>dotnet</a>
<a href=/tags/csharp/>csharp</a>
<a href=/tags/wpf/>wpf</a>
<a href=/tags/design-patterns/>design-patterns</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>使用 CC BY-NC-SA 4.0 协议</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/posts/more-observable-collections/><div class=article-details><h2 class=article-title>借助 ObservableCollections 获得更多具有通知功能的集合类型</h2></div></a></article><article><a href=/posts/contentcontrol-vs-contentpresenter/><div class=article-details><h2 class=article-title>WPF 中的 ContentControl 及 ContentPresenter 有何异同？</h2></div></a></article><article class=has-image><a href=/posts/objectdataprovider-tips/><div class=article-image><img src=https://s2.loli.net/2025/03/04/6BmTwRWGapOPoIE.webp loading=lazy data-key=objectdataprovider-tips data-hash=https://s2.loli.net/2025/03/04/6BmTwRWGapOPoIE.webp></div><div class=article-details><h2 class=article-title>WPF 中 ObjectDataProvider 的一些有趣用法</h2></div></a></article><article class=has-image><a href=/posts/grid-of-controls/><div class=article-image><img src=https://s2.loli.net/2024/12/26/kgGyXcYIlnMNpSr.jpg loading=lazy data-key=grid-of-controls data-hash=https://s2.loli.net/2024/12/26/kgGyXcYIlnMNpSr.jpg></div><div class=article-details><h2 class=article-title>如何在 WPF 中高效布局多行多列的控件</h2></div></a></article><article class=has-image><a href=/posts/valueconverter-tips-and-tricks/><div class=article-image><img src=https://s2.loli.net/2024/12/18/dRbx2KJsHOmaPG7.webp loading=lazy data-key=valueconverter-tips-and-tricks data-hash=https://s2.loli.net/2024/12/18/dRbx2KJsHOmaPG7.webp></div><div class=article-details><h2 class=article-title>WPF 值转换器（ValueConverter）的一些实用技巧</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=BYJRK/byjrk.github.io data-repo-id=R_kgDOLoIulQ data-category=Announcements data-category-id=DIC_kwDOLoIulc4CenQE data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark")}})()</script><footer class=site-footer><section class=copyright>&copy;
2023 -
2025 寒流の编程笔记</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>